{
    parserClass = "com.github.cucapra.futil.parser.FutilParser"
    parserUtilClass = "com.github.cucapra.futil.psi.FutilParserUtil"

    extends = "com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix = "Futil"
    psiImplClassSuffix = "Node"
    psiPackage = "com.github.cucapra.futil.psi"
    psiImplPackage = "com.github.cucapra.futil.psi.impl"

    elementTypeHolderClass = "com.github.cucapra.futil.psi.FutilTypes"
    elementTypeClass = "com.github.cucapra.futil.psi.FutilElementType"
    tokenTypeClass = "com.github.cucapra.futil.psi.FutilElementType"

    psiImplUtilClass = "com.github.cucapra.futil.psi.FutilASTExtension"
    generateTokenAccessors = true
    tokens = [
        COMMENT = 'regexp:(//|#)[^\r\n]*'
        BLOCK_COMMENT = 'regexp:[/][*][^*]*[*]+([^/*][^*]*[*]+)*[/]'

        AS = "as"
        NULL = 'null'
        BOOLEAN = 'regexp:true|false'

        SYMBOL = 'Symbol'
        STRING = 'String'
        BITS = 'Bits'
        NUMBER = 'Number'

        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
        ACCENT = '^'
        ANGLE_L = '<'
        ANGLE_R = '>'
        QUOTATION = '"'
        ESCAPE = '\'
        NON_ESCAPE = 'regexp:[^\\]'
        EQ = '='
        COLON = ':'
        SEMICOLON = ';'
        COMMA = ','
        CITE = '$'
        DOT = '.'
        STAR = '*'
        QUESTION = '?'
        AT = '@'
//      SPACE='regexp:\s+'
//      ANY = 'regexp:.'
    ]
}

Futil ::= top_stat*;
private top_stat ::=
    import_statement
  | component_statement
  | SEMICOLON
  ;
private inner_stat ::=
    seq_stat
  | annotation? expression
  ;
private seq_stat ::=
    group_statement
  | comb_statement
  | par_statement
  | while_statement
  | normal_statement
  ;
// ---------------------------------------------------------------------------------------------------------------------
import_statement ::= IMPORT STRING;
IMPORT ::= "import"
// ---------------------------------------------------------------------------------------------------------------------
component_statement ::= COMPONENT component_name component_target <<brace inner_stat SEMICOLON>>;
component_name ::= identifier <<parenthesis identifier SEMICOLON>>
component_target ::= TO <<parenthesis identifier SEMICOLON>>
COMPONENT ::= "component"
// ---------------------------------------------------------------------------------------------------------------------
group_statement ::= GROUP identifier <<brace inner_stat SEMICOLON>>;
GROUP  ::= "group";
// ---------------------------------------------------------------------------------------------------------------------
comb_statement ::= COMB GROUP identifier <<brace inner_stat SEMICOLON>>;
COMB ::= "comb";
// ---------------------------------------------------------------------------------------------------------------------
par_statement ::= seq_k <<brace seq_s SEMICOLON>> BRACE_R;
private seq_k ::= SEQ | PAR;
private seq_s ::= seq_stat | identifier;
SEQ ::= "seq";
PAR ::= "par"
// ---------------------------------------------------------------------------------------------------------------------
while_statement ::= WHILE namespace [WITH identifier] <<brace inner_stat SEMICOLON>>;
WHILE ::= "while";
WITH ::= "with";
// ---------------------------------------------------------------------------------------------------------------------
normal_statement ::= identifier <<brace inner_stat SEMICOLON>>;
// ---------------------------------------------------------------------------------------------------------------------
annotation ::= annotation_mark;
annotation_mark ::= AT SYMBOL?;
// ---------------------------------------------------------------------------------------------------------------------
expression ::= lhs EQ rhs;
rhs ::= value [QUESTION value];
lhs ::= namespace slice?;
// ---------------------------------------------------------------------------------------------------------------------
value ::= call | namespace | NUMBER BITS?
// ---------------------------------------------------------------------------------------------------------------------
call ::= identifier <<parenthesis rhs COMMA>>;
// ---------------------------------------------------------------------------------------------------------------------
slice ::= <<bracket identifier COMMA>>
// ---------------------------------------------------------------------------------------------------------------------
namespace ::= identifier (DOT identifier)*;
identifier ::= SYMBOL
// ---------------------------------------------------------------------------------------------------------------------
meta parenthesis ::= PARENTHESIS_L [<<param>> (<<sep>> <<param>>)* [<<sep>>]] PARENTHESIS_R;
meta bracket ::= BRACKET_L [<<param>> (<<sep>> <<param>>)* [<<sep>>]] BRACKET_R;
meta brace   ::= BRACE_L [<<param>> (<<sep>> <<param>>)* [<<sep>>]] BRACE_R
meta angle   ::= ANGLE_L [<<param>> (<<sep>> <<param>>)* [<<sep>>]] ANGLE_R